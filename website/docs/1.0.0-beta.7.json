{"api/navigators/DrawerNavigator":"# DrawerNavigator\n\nUsed to easily set up a screen with a drawer navigation.\n\n```js\nclass MyHomeScreen extends React.Component {\n  static navigationOptions = {\n    drawer: () => ({\n      label: 'Home',\n      icon: ({ tintColor }) => (\n        <Image\n          source={require('./chats-icon.png')}\n          style={[styles.icon, {tintColor: tintColor}]}\n        />\n      ),\n    }),\n  }\n\n  render() {\n    return (\n      <Button\n        onPress={() => this.props.navigation.navigate('Notifications')}\n        title=\"Go to notifications\"\n      />\n    );\n  }\n}\n\nclass MyNotificationsScreen extends React.Component {\n  static navigationOptions = {\n    drawer: () => ({\n      label: 'Notifications',\n      icon: ({ tintColor }) => (\n        <Image\n          source={require('./notif-icon.png')}\n          style={[styles.tabIcon, {tintColor: tintColor}]}\n        />\n      ),\n    }),\n  }\n\n  render() {\n    return (\n      <Button\n        onPress={() => this.props.navigation.goBack()}\n        title=\"Go back home\"\n      />\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  icon: {\n    width: 24,\n    height: 24,\n  },\n});\n\nconst MyApp = DrawerNavigator({\n  Home: {\n    screen: MyHomeScreen,\n  },\n  Notifications: {\n    screen: MyNotificationsScreen,\n  },\n});\n```\n\nTo open and close drawer, navigate to `'DrawerOpen'` and `'DrawerClose'` respectively.\n\n```js\nthis.props.navigation.navigate('DrawerOpen'); // open drawer\nthis.props.navigation.navigate('DrawerClose'); // close drawer\n```\n\n## API Definition\n\n```js\nDrawerNavigator(RouteConfigs, DrawerNavigatorConfig)\n```\n\n### RouteConfigs\n\nThe route configs object is a mapping from route name to a route config, which tells the navigator what to present for that route, see [example](https://github.com/coodoo/react-navigation/blob/master/docs/api/navigators/StackNavigator.md#routeconfigs) from `StackNavigator`.\n\n\n### DrawerNavigatorConfig\n\n- `drawerWidth` - Width of the drawer\n- `drawerPosition` - Options are `left` or `right`. Default is `left` position.\n- `contentComponent` - Component to use to render the navigation items. Receives the `navigation` prop for the drawer. Defaults to `DrawerView.Items`.\n- `contentOptions` - Configure the drawer content, see below.\n\nSeveral options get passed to the underlying router to modify navigation logic:\n\n- `initialRouteName` - The routeName for the initial route.\n- `order` - Array of routeNames which defines the order of the drawer items.\n- `paths` - Provide a mapping of routeName to path config, which overrides the paths set in the routeConfigs.\n- `backBehavior` - Should the back button cause switch to the initial route? If yes, set to `initialRoute`, otherwise `none`. Defaults to `initialRoute` behavior.\n\n### `contentOptions` for `DrawerView.Items`\n\n- `activeTintColor` - label and icon color of the active label\n- `activeBackgroundColor` - background color of the active label\n- `inactiveTintColor` - label and icon color of the inactive label\n- `inactiveBackgroundColor` - background color of the inactive label\n- `style` - style object for the content section\n\n#### Example:\n\n```js\ncontentOptions: {\n  activeTintColor: '#e91e63',\n  style: {\n    marginVertical: 0,\n  }\n}\n```\n\n### Screen Navigation Options\n\nUsually you define static `navigationOptions` on your screen component. For example:\n\n```jsx\nclass ProfileScreen extends React.Component {\n\n  static navigationOptions = {\n\n    title: ({ state }) => `${state.params.name}'s Profile!`,\n\n    drawer: {\n      icon: (\n        <Image src={require('./my-icon.png')} />\n      ),\n    },\n  };\n  ...\n```\n\nAll `navigationOptions` for the `DrawerNavigator`:\n\n- `title` - a title (string) of the scene\n- `drawer` - a config object for the drawer:\n  - `label` - String, React Element or a function that given `{ focused: boolean, tintColor: string }` returns a React.Element, to display in drawer sidebar. When undefined, scene `title` is used\n  - `icon` - React Element or a function, that given `{ focused: boolean, tintColor: string }` returns a React.Element, to display in drawer sidebar\n\n\n### Navigator Props\n\nThe navigator component created by `DrawerNavigator(...)` takes the following props:\n\n- `screenProps` - Pass down extra options to child screens, for example:\n\n\n ```jsx\n const DrawerNav = DrawerNavigator({\n   // config\n });\n \n <DrawerNav\n   screenProps={/* this prop will get passed to the screen components as this.props.screenProps */}\n />\n ```\n","api/navigators/Navigators":"# Navigators\n\nNavigators allow you to define your application's navigation structure. Navigators also render common elements such as headers and tab bars which you can configure.\n\nUnder the hood, navigators are plain React components.\n\n## Built-in Navigators\n\n`react-navigation` includes the following functions to help you create navigators:\n\n- [StackNavigator](/docs/navigators/stack) - Renders one screen at a time and provides transitions between screens. When a new screen is opened it is placed on top of the stack.\n- [TabNavigator](/docs/navigators/tab) - Renders a tab bar that lets the user switch between several screens\n- [DrawerNavigator](/docs/navigators/drawer) - Provides a drawer that slides in from the left of the screen\n\n## Rendering screens with Navigators\n\nThe navigators render application screens which are just React components.\n\nTo learn how to create screens, read about:\n- [Screen `navigation` prop](/docs/navigators/navigation-prop) to allow the screen to dispatch navigation actions, such as opening another screen\n- [Screen `navigationOptions`](/docs/navigators/navigation-options) to customize how the screen gets presented by the navigator (e.g. header title, tab label)\n\n### Calling Navigate on Top Level Component\n\nIn case you want to use Navigator from the same level you declare it you can use react's [`ref`](https://facebook.github.io/react/docs/refs-and-the-dom.html#the-ref-callback-attribute) option:  \n```js\nconst AppNavigator = StackNavigator(SomeAppRouteConfigs);\n\nclass App extends React.Component {\n  someEvent() {\n    // call navigate for AppNavigator here:\n    this.navigator && this.navigator.dispatch({ type: 'Navigate', routeName, params });\n  }\n  render() {\n    return (\n      <AppNavigator ref={nav => { this.navigator = nav; }} />\n    );\n  }\n}\n```\nPlease notice that this solution should only be used on the top level navigator.  \n\n## Navigation Containers\n\nThe built in navigators can automatically behave like top-level navigators when the navigation prop is missing. This functionality provides a transparent navigation container, which is where the top-level navigation prop comes from.\n\nWhen rendering one of the included navigators, the navigation prop is optional. When it is missing, the container steps in and manages its own navigation state. It also handles URLs, external linking, and Android back button integration.\n\nFor the purpose of convenience, the built-in navigators have this ability because behind the scenes they use `createNavigationContainer`. Usually, navigators require a navigation prop in order to function.\n\n### `onNavigationStateChange(prevState, newState)`\n\nSometimes it is useful to know when navigation state managed by the top-level navigator changes. For this purpose, this function gets called every time with the previous state and the new state of the navigation.\n\n### `containerOptions`\n\nThese options can be used to configure a navigator when it is used at the top level.\n\nAn error will be thrown if a navigator is configured with `containerOptions` and also receives a `navigation` prop, because in that case it would be unclear if the navigator should handle its own state.\n\n- `URIPrefix` - The prefix of the URIs that the app might handle. This will be used when handling a [deep link](/docs/guides/linking) to extract the path passed to the router.","api/navigators/StackNavigator":"# StackNavigator\n\nProvides a way for your app to transition between screens where each new screen is placed on top of a stack.\n\nBy default the StackNavigator is configured to have the familiar iOS and Android look & feel: new screens slide in from the right on iOS, fade in from the bottom on Android. On iOS the StackNavigator can also be configured to a modal style where screens slide in from the bottom.\n\n```jsx\n\nclass MyHomeScreen extends React.Component {\n  static navigationOptions = {\n    title: 'Home',\n  }\n\n  render() {\n    return (\n      <Button\n        onPress={() => this.props.navigation.navigate('Profile', {name: 'Lucy'})}\n        title=\"Go to Lucy's profile\"\n      />\n    );\n  }\n}\n\nconst ModalStack = StackNavigator({\n  Home: {\n    screen: MyHomeScreen,\n  },\n  Profile: {\n    path: 'people/:name',\n    screen: MyProfileScreen,\n  },\n});\n```\n\n## API Definition\n\n```js\nStackNavigator(RouteConfigs, StackNavigatorConfig)\n```\n\n### RouteConfigs\n\nThe route configs object is a mapping from route name to a route config, which tells the navigator what to present for that route.\n\n```js\nStackNavigator({\n\n  // For each screen that you can navigate to, create a new entry like this:\n  Profile: {\n\n    // `ProfileScreen` is a React component that will be the main content of the screen.\n    screen: ProfileScreen,\n    // When `ProfileScreen` is loaded by the StackNavigator, it will be given a `navigation` prop.\n\n    // Optional: When deep linking or using react-navigation in a web app, this path is used:\n    path: 'people/:username',\n    // The action and route params are extracted from the path.\n\n    // Optional: Override the `navigationOptions` for the screen\n    navigationOptions: {\n      title: ({state}) => `${state.params.username}'s Profile'`,\n    },\n  },\n\n  ...MyOtherRoutes,\n});\n```\n\n### StackNavigatorConfig\n\nOptions for the router:\n\n- `initialRouteName` - Sets the default screen of the stack. Must match one of the keys in route configs.\n- `initialRouteParams` - The params for the initial route\n- `navigationOptions` - Default navigation options to use for screens\n- `paths` - A mapping of overrides for the paths set in the route configs\n\nVisual options:\n\n- `mode` - Defines the style for rendering and transitions:\n  - `card` - Use the standard iOS and Android screen transitions. This is the default.\n  - `modal` - Make the screens slide in from the bottom which is a common iOS pattern. Only works on iOS, has no effect on Android.\n- `headerMode` - Specifies how the header should be rendered:\n  - `float` - Render a single header that stays at the top and animates as screens are changed. This is a common pattern on iOS.\n  - `screen` - Each screen has a header attached to it and the header fades in and out together with the screen. This is a common pattern on Android.\n  - `none` - No header will be rendered.\n- `cardStyle` - Use this prop to override or extend the default style for an individual card in stack.\n- `onTransitionStart` - Function to be invoked when the card transition animation is about to start.\n- `onTransitionEnd` - Function to be invoked once the card transition animation completes.\n\n\n### Screen Navigation Options\n\nUsually you define static `navigationOptions` on your screen component. For example:\n\n```jsx\nclass ProfileScreen extends React.Component {\n\n  static navigationOptions = {\n\n    title: ({ state }) => `${state.params.name}'s Profile!`,\n\n    header: ({ state, setParams }) => ({\n      // Render a button on the right side of the header\n      // When pressed switches the screen to edit mode.\n      right: (\n        <Button\n          title={state.params.editing ? 'Done' : 'Edit'}\n          onPress={() => setParams({editing: state.params.editing ? false : true})}\n        />\n      ),\n    }),\n  };\n  ...\n```\n\nAll `navigationOptions` for the `StackNavigator`:\n\n- `title` - a title (string) of the scene\n- `header` - a config object for the header bar:\n  - `visible` - Boolean toggle of header visibility. Only works when `headerMode` is `screen`.\n  - `title` - String or React Element used by the header. Defaults to scene `title`\n  - `backTitle` - Title string used by the back button on iOS or `null` to disable label. Defaults to scene `title`\n  - `right` - React Element to display on the right side of the header\n  - `left` - React Element to display on the left side of the header\n  - `style` - Style object for the header\n  - `titleStyle` - Style object for the title component\n  - `tintColor` - Tint color for the header\n- `cardStack` - a config object for the card stack:\n  - `gesturesEnabled` - Whether you can use gestures to dismiss this screen. Defaults to true on iOS, false on Android\n\n### Navigator Props\n\nThe navigator component created by `StackNavigator(...)` takes the following props:\n\n- `screenProps` - Pass down extra options to child screens, for example:\n\n\n ```jsx\n const SomeStack = StackNavigator({\n   // config\n });\n\n <SomeStack\n   screenProps={/* this prop will get passed to the screen components as this.props.screenProps */}\n />\n ```\n\n### Examples\n\nSee the examples [SimpleStack.js](https://github.com/react-community/react-navigation/tree/master/examples/NavigationPlayground/js/SimpleStack.js) and [ModalStack.js](https://github.com/react-community/react-navigation/tree/master/examples/NavigationPlayground/js/ModalStack.js) which you can run locally as part of the [NavigationPlayground](https://github.com/react-community/react-navigation/tree/master/examples/NavigationPlayground) app.\n","api/navigators/TabNavigator":"# TabNavigator\n\nUsed to easily set up a screen with several tabs with a TabRouter.\n\n```js\nclass MyHomeScreen extends React.Component {\n  static navigationOptions = {\n    tabBar: {\n      label: 'Home',\n      // Note: By default the icon is only shown on iOS. Search the showIcon option below.\n      icon: ({ tintColor }) => (\n        <Image\n          source={require('./chats-icon.png')}\n          style={[styles.icon, {tintColor: tintColor}]}\n        />\n      ),\n    },\n  }\n\n  render() {\n    return (\n      <Button\n        onPress={() => this.props.navigation.navigate('Notifications')}\n        title=\"Go to notifications\"\n      />\n    );\n  }\n}\n\nclass MyNotificationsScreen extends React.Component {\n  static navigationOptions = {\n    tabBar: {\n      label: 'Notifications',\n      icon: ({ tintColor }) => (\n        <Image\n          source={require('./notif-icon.png')}\n          style={[styles.tabIcon, {tintColor: tintColor}]}\n        />\n      ),\n    },\n  }\n\n  render() {\n    return (\n      <Button\n        onPress={() => this.props.navigation.goBack()}\n        title=\"Go back home\"\n      />\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  icon: {\n    width: 26,\n    height: 26,\n  },\n});\n\nconst MyApp = TabNavigator({\n  Home: {\n    screen: MyHomeScreen,\n  },\n  Notifications: {\n    screen: MyNotificationsScreen,\n  },\n}, {\n  tabBarOptions: {\n    activeTintColor: '#e91e63',\n  },\n});\n```\n\n## API Definition\n\n```js\nTabNavigator(RouteConfigs, TabNavigatorConfig)\n```\n\n### RouteConfigs\n\nThe route configs object is a mapping from route name to a route config, which tells the navigator what to present for that route, see [example](https://github.com/coodoo/react-navigation/blob/master/docs/api/navigators/StackNavigator.md#routeconfigs) from `StackNavigator`.\n\n### TabNavigatorConfig\n\n- `tabBarComponent` - component to use as the tab bar, e.g. `TabView.TabBarBottom`\n(this is the default on iOS), `TabView.TabBarTop`\n(this is the default on Android)\n- `tabBarPosition` - position of the tab bar, can be `'top'` or `'bottom'`\n- `swipeEnabled` - whether to allow swiping between tabs\n- `animationEnabled` - whether to animate when changing tabs\n- `lazyLoad` - whether to lazily render tabs as needed as opposed to rendering them upfront\n- `tabBarOptions` - configure the tab bar, see below.\n\nSeveral options get passed to the underlying router to modify navigation logic:\n\n- `initialRouteName` - The routeName for the initial tab route when first loading\n- `order` - Array of routeNames which defines the order of the tabs\n- `paths` - Provide a mapping of routeName to path config, which overrides the paths set in the routeConfigs.\n- `backBehavior` - Should the back button cause a tab switch to the initial tab? If yes, set to `initialRoute`, otherwise `none`. Defaults to `initialRoute` behavior.\n\n### `tabBarOptions` for `TabBarBottom` (default tab bar on iOS)\n\n- `activeTintColor` - label and icon color of the active tab\n- `activeBackgroundColor` - background color of the active tab\n- `inactiveTintColor` - label and icon color of the inactive tab\n- `inactiveBackgroundColor` - background color of the inactive tab\n- `showLabel` - whether to show label for tab, default is true\n- `style` - style object for the tab bar\n- `labelStyle` - style object for the tab label\n\nExample:\n\n```js\ntabBarOptions: {\n  activeTintColor: '#e91e63',\n  labelStyle: {\n    fontSize: 12,\n  },\n  style: {\n    backgroundColor: 'blue',\n  },\n}\n```\n\n### `tabBarOptions` for `TabBarTop` (default tab bar on Android)\n\n- `activeTintColor` - label and icon color of the active tab\n- `inactiveTintColor` - label and icon color of the inactive tab\n- `showIcon` - whether to show icon for tab, default is false\n- `showLabel` - whether to show label for tab, default is true\n- `upperCaseLabel` - whether to make label uppercase, default is true\n- `pressColor` - color for material ripple (Android >= 5.0 only)\n- `pressOpacity` - opacity for pressed tab (iOS and Android < 5.0 only)\n- `scrollEnabled` - whether to enable scrollable tabs\n- `tabStyle` - style object for the tab\n- `indicatorStyle` - style object for the tab indicator (line at the bottom of the tab)\n- `labelStyle` - style object for the tab label\n- `style` - style object for the tab bar\n\nExample:\n\n```js\ntabBarOptions: {\n  labelStyle: {\n    fontSize: 12,\n  },\n  style: {\n    backgroundColor: 'blue',\n  },\n}\n```\n\n### Screen Navigation Options\n\nUsually you define static `navigationOptions` on your screen component. For example:\n\n```jsx\nclass ProfileScreen extends React.Component {\n\n  static navigationOptions = {\n\n    title: ({ state }) => `${state.params.name}'s Profile!`,\n\n    tabBar: ({ state, setParams }) => ({\n      icon: (\n        <Image src={require('./my-icon.png')} />\n      ),\n    }),\n  };\n  ...\n```\n\nAll `navigationOptions` for the `TabNavigator`:\n\n- `title` - a title (string) of the scene\n- `tabBar` - a config object for the tab bar:\n  - `visible` - Boolean toggle of tab bar visibility\n  - `icon` - React Element or a function that given `{ focused: boolean, tintColor: string }` returns a React.Element, to display in tab bar\n  - `label` - Title string of a tab displayed in the tab bar. When undefined, scene `title` is used. To hide, see `tabBarOptions.showLabel` in the previous section\n  \n### Navigator Props\n\nThe navigator component created by `TabNavigator(...)` takes the following props:\n\n- `screenProps` - Pass down extra options to child screens, for example:\n\n\n ```jsx\n const TabNav = TabNavigator({\n   // config\n });\n \n <TabNav\n   screenProps={/* this prop will get passed to the screen components as this.props.screenProps */}\n />\n ```\n \n","api/routers/Routers":"# Routers\n\nRouters define a component's navigation state, and they allow the developer to define paths and actions that can be handled.\n\n\n## Built-In Routers\n\n`react-navigation` ships with a few standard routers:\n\n- [StackRouter](/docs/routers/stack)\n- [TabRouter](/docs/routers/tabs)\n\n\n## Using Routers\n\nTo make a navigator manually, put a static `router` on a component. (To quickly make a navigator with a built-in component, it may be easier to use a [Navigator Factory](/docs/navigators) instead)\n\n```js\nclass MyNavigator extends React.Component {\n    static router = StackRouter(routes, config);\n    ...\n}\n```\n\nNow you can use this component as a `screen` in another navigator, and the navigation logic for `MyNavigator` will be defined by this `StackRouter`.\n\n\n## Customizing Routers\n\nSee the [Custom Router API spec](/docs/routers/api) to learn about the API of `StackRouter` and `TabRouter`. You can override the router functions as you see fit:\n\n### Custom Navigation Actions\n\nTo override navigation behavior, you can override the navigation state logic in `getStateForAction`, and manually manipulate the `routes` and `index`.\n\n```js\nconst MyApp = StackNavigator({\n  Home: { screen: HomeScreen },\n  Profile: { screen: ProfileScreen },\n}, {\n  initialRouteName: 'Home',\n})\nMyApp.router = {\n  ...MyApp.router,\n  getStateForAction(action, state) {\n    if (state && action.type === 'PushTwoProfiles') {\n      const routes = [\n        ...state.routes,\n        {key: 'A', routeName: 'Profile', params: { name: action.name1 }},\n        {key: 'B', routeName: 'Profile', params: { name: action.name2 }},\n      ];\n      return {\n        ...state,\n        routes,\n        index: routes.length - 1,\n      };\n    }\n    return MyApp.router.getStateForAction(action, state);\n  },\n};\n```\n\n\n\n### Blocking Navigation Actions\n\nSometimes you may want to prevent some navigation activity, depending on your route.\n\n```js\nconst MyStackRouter = StackRouter({\n  Home: { screen: HomeScreen },\n  Profile: { screen: ProfileScreen },\n}, {\n  initialRouteName: 'Home',\n})\nconst MyAppRouter = {\n  ...MyStackRouter,\n  getStateForAction(action, state) {\n    if (\n      state &&\n      action.type === NavigationActions.BACK &&\n      state.routes[state.index].params.isEditing\n    ) {\n      // Returning null from getStateForAction means that the action\n      // has been handled/blocked, but there is not a new state\n      return null;\n    }\n    return MyStackRouter.getStateForAction(action, state);\n  },\n};\n```\n\n\n### Handling Custom URIs\n\nPerhaps your app has a unique URI which the built-in routers cannot handle. You can always extend the router `getActionForPathAndParams`.\n\n```js\n\nimport { NavigationActions } from 'react-navigation'\n\nconst MyApp = StackNavigator({\n  Home: { screen: HomeScreen },\n  Profile: { screen: ProfileScreen },\n}, {\n  initialRouteName: 'Home',\n})\nMyApp.router = {\n  ...MyApp.router,\n  getActionForPathAndParams(path, params) {\n    if (\n      path === 'my/custom/path' &&\n      params.magic === 'yes'\n    ) {\n      // returns a profile navigate action for /my/custom/path?magic=yes\n      return NavigationActions.navigate({\n        routeName: 'Profile',\n        action: NavigationActions.navigate({\n          // This child action will get passed to the child router\n          // ProfileScreen.router.getStateForAction to get the child\n          // navigation state.\n          routeName: 'Friends',\n        }),\n      });\n      return null;\n    }\n    return MyApp.router.getStateForAction(action, state);\n  },\n};\n```\n","api/routers/RoutersAPI":"## Custom Router API\n\nYou can make your own router by building an object with the following functions:\n\n```js\nconst MyRouter = {\n  getStateForAction: (action) => ({}),\n  getActionForPathAndParams: (path, params) => null,\n  getPathAndParamsForState: (state) => null,\n  getComponentForState: (state) => MyScreen,\n  getComponentForRouteName: (routeName) => MyScreen,\n};\n\n// Now, you can make a navigator by putting the router on it:\nclass MyNavigator extends React.Component {\n  static router = MyRouter;\n  render() {\n    ...\n  }\n}\n```\n\n![Routers manage the relationship between URIs, actions, and navigation state](/assets/routers-concept-map.png)\n\n\n### `getStateForAction(action, state)`\n\nDefines the navigation state in response to a given action. This function will be run when an action gets passed into `props.navigation.dispatch(`, or when any of the helper functions are called, like `navigation.navigate(`.\n\nTypically this should return a navigation state, with the following form:\n\n```\n{\n  index: 1, // identifies which route in the routes array is active\n  routes: [\n    {\n      // Each route needs a name to identify the type.\n      routeName: 'MyRouteName',\n\n      // A unique identifier for this route in the routes array:\n      key: 'myroute-123',\n      // (used to specify the re-ordering of routes)\n\n      // Routes can have any data, as long as key and routeName are correct\n      ...randomRouteData,\n    },\n    ...moreRoutes,\n  ]\n}\n```\n\nIf the router has handled the action externally, or wants to swallow it without changing the navigation state, this function will return `null`.\n\n### `getComponentRouteName(routeName)`\n\nReturns the child component or navigator for the given route name.\n\nSay a router `getStateForAction` outputs a state like this:\n```js\n{\n  index: 1,\n  routes: [\n    { key: 'A', routeName: 'Foo' },\n    { key: 'B', routeName: 'Bar' },\n  ],\n}\n```\n\nBased on the routeNames in the state, the router is responsible for returning valid components when calling `router.getComponentRouteName('Foo')` or `router.getComponentRouteName('Bar')`.\n\n### `getComponentForState(state)`\n\nReturns the active component for a deep navigation state.\n\n### `getActionForPathAndParams`\n\nReturns an optional navigation action that should be used when the user navigates to this path and provides optional query parameters.\n\n### `getPathAndParamsForState`\n\nReturns the path and params that can be put into the URL to link the user back to the same spot in the app.\n\nThe path/params that are output from this should form an action when passed back into the router's `getActionForPathAndParams`. That action should take you to a similar state once passed through `getStateForAction`.\n\n### `getScreenConfig`\n\nUsed to retrieve the navigation options for a route. Must provide the screen's current navigation prop, and the name of the option to be retrieved.\n\n- `navigation` - This is the navigation prop that the screen will use, where the state refers to the screen's route/state. Dispatch will trigger actions in the context of that screen.\n- `optionName` - What named option is being fetched, such as 'title'\n\nInside an example view, perhaps you need to fetch the configured title:\n```js\n// First, prepare a navigation prop for your child, or re-use one if already available.\nconst childNavigation = addNavigationHelpers({\n  // In this case we use navigation.state.index because we want the title for the active route.\n  state: navigation.state.routes[navigation.state.index],\n  dispatch: navigation.dispatch,\n})\nconst screenTitle = this.props.router.getScreenConfig(childNavigation, 'title');\n```\n","api/routers/StackRouter":"# StackRouter\n\nManage the logical navigation stack, including pushing, popping, and handling path parsing to create a deep stack.\n\nLet's take a look at a simple stack router:\n\n```js\nconst MyApp = StackRouter({\n  Home: { screen: HomeScreen },\n  Profile: { screen: ProfileScreen },\n}, {\n  initialRouteName: 'Home',\n})\n```\n\n\n### RouteConfig\n\nA basic stack router expects a route config object. Here is an example configuration:\n\n```js\nconst MyApp = StackRouter({ // This is the RouteConfig:\n  Home: {\n    screen: HomeScreen,\n    path: '',\n  },\n  Profile: {\n    screen: ProfileScreen,\n    path: 'profile/:name',\n  },\n  Settings {\n    // This can be handy to lazily require a screen:\n    getScreen: () => require('Settings').default,\n    // Note: Child navigators cannot be configured using getScreen because\n    // the router will not be accessible. Navigators must be configured\n    // using `screen: MyNavigator`\n    path: 'settings',\n  },\n});\n```\n\nEach item in the config may have the following:\n\n- `path` - Specify the path and params to be parsed for item in the stack\n- `screen` - Specify the screen component or child navigator\n- `getScreen` - Set a lazy getter for a screen component (but not navigators)\n\n\n### StackConfig\n\nConfig options that are also passed to the stack router.\n\n- `initalRouteName` - The routeName for the default route when the stack first loads\n- `initialRouteParams` - Default params of the initial route\n- `paths` - Provide a mapping of routeName to path config, which overrides the paths set in the routeConfigs.\n\n### Supported Actions\n\nThe stack router may respond to the following navigation actions. The router will generally delegate the action handling to a child router, if possible.\n\n- Navigate - Will push a new route on the stack if the routeName matches one of the router's routeConfigs\n- Back - Goes back (pops)\n- Reset - Clears the stack and provides new actions to create a fully new navigation state\n- SetParams - An action that a screen dispatches to change the params of the current route.\n","api/routers/TabRouter":"# TabRouter\n\nManage a set of tabs in the application, handle jumping to tabs, and handle the back button press to jump to the initial tab.\n\nLet's take a look at a simple tabs router:\n\n```js\nconst MyApp = TabRouter({\n  Home: { screen: HomeScreen },\n  Settings: { screen: SettingsScreen },\n}, {\n  initialRouteName: 'Home',\n})\n```\n\n\n### RouteConfig\n\nA tabs router has a routeConfig for each possible tab:\n\n```js\nconst MyApp = TabRouter({ // This is the RouteConfig:\n  Home: {\n    screen: HomeScreen,\n    path: 'main',\n  },\n  Settings: {\n    // This can be handy to lazily require a tab:\n    getScreen: () => require('./SettingsScreen').default,\n    // Note: Child navigators cannot be configured using getScreen because\n    // the router will not be accessible. Navigators must be configured\n    // using `screen: MyNavigator`\n    path: 'settings',\n  },\n});\n```\n\nEach item in the config may have the following:\n\n- `path` - Specify the path for each tab\n- `screen` - Specify the screen component or child navigator\n- `getScreen` - Set a lazy getter for a screen component (but not navigators)\n\n\n### Tab Router Config\n\nConfig options that are also passed to the router.\n\n- `initialRouteName` - The routeName for the initial tab route when first loading\n- `order` - Array of routeNames which defines the order of the tabs\n- `paths` - Provide a mapping of routeName to path config, which overrides the paths set in the routeConfigs.\n- `backBehavior` - Should the back button cause a tab switch to the initial tab? If yes, set to `initialRoute`, otherwise `none`. Defaults to `initialRoute` behavior.\n\n### Supported Actions\n\nThe tabs router may respond to the following navigation actions. The router will generally delegate the action handling to a child router, if possible.\n\n- Navigate - Will jump to the routeName if it matches a tab\n- Back - Goes to the first tab, if not already selected\n- SetParams - An action that a screen dispatches to change the params of the current route.\n","api/views/Transitioner":"# Transitioner\n\n`Transitioner` is a React component that helps manage transitions for complex animated components. It manages the timing of animations and keeps track of various screens as they enter and leave, but it doesn't know what anything looks like, because rendering is entirely deferred to the developer.\n\nUnder the covers, `Transitioner` is used to implement `CardStack`, and hence the `StackNavigator`.\n\nThe most useful thing `Transitioner` does is to take in a prop of the current navigation state. When routes are removed from that navigation state, `Transitioner` will coordinate the transition away from those routes, keeping them on screen even though they are gone from the navigation state.\n\n\n## Example\n\n```jsx\nclass MyNavView extends Component {\n  ...\n  render() {\n    return (\n      <Transitioner\n        configureTransition={this._configureTransition}\n        navigation={this.props.navigation}\n        render={this._render}\n        onTransitionStart={this.onTransitionStart}\n        onTransitionEnd={this.onTransitionEnd}\n      />\n    );\n}\n```\n\n## Props\n\n### `configureTransition` function\n\nInvoked on `Transitioner.componentWillReceiveProps`, this function allows customization of animation parameters such as `duration`. The value returned from this function will be fed into a timing function, by default `Animated.timing()`, as its config.\n\n#### Examples\n\n```js\n_configureTransition(transitionProps, prevTransitionProps) {\n  return {\n    // duration in milliseconds, default: 250\n    duration: 500,\n    // An easing function from `Easing`, default: Easing.inOut(Easing.ease)\n    easing: Easing.bounce,\n  }\n}\n```\n\nNote: `duration` and `easing` are only applicable when the timing function is `Animated.timing`. We can also use a different timing function and its corresponding config parameters, like so:\n\n```js\n_configureTransition(transitionProps, prevTransitionProps) {\n  return {\n    // A timing function, default: Animated.timing.\n    timing: Animated.spring,\n    // Some parameters relevant to Animated.spring\n    friction: 1,\n    tension: 0.5,\n  }\n}\n```\n\n#### Flow definition\n\n```js\n  configureTransition: (\n    transitionProps: NavigationTransitionProps,\n    prevTransitionProps: ?NavigationTransitionProps,\n  ) => NavigationTransitionSpec,\n```\n\n#### Parameters\n- `transitionProps`: the current [NavigationTransitionProps](https://github.com/react-community/react-navigation/blob/master/src/TypeDefinition.js#L273) created from the current navigation state and props\n- `prevTransitionProps`: the previous [NavigationTransitionProps](https://github.com/react-community/react-navigation/blob/master/src/TypeDefinition.js#L273) created from the previous navigation state and props\n\n#### Returns\n- An object of type [NavigationTransitionSpec](https://github.com/react-community/react-navigation/blob/master/src/TypeDefinition.js#L316) that will be fed into an Animated timing function as its config\n\n\n### `navigationState` object\nA plain object that represents the navigation state\n\n#### Example value\n\n```js\n{\n   // Index refers to the active child route in the routes array.\n  index: 1,\n  routes: [\n    { key: 'DF2FGWGAS-12', routeName: 'ContactHome' },\n    { key: 'DF2FGWGAS-13', routeName: 'ContactDetail', params: { personId: 123 } }\n  ]\n}\n```\n\n#### Flow definition\n```js\nexport type NavigationState = {\n  index: number,\n  routes: Array<NavigationRoute>,\n};\n```\n\nFor more information about the `NavigationRoute` type, check out its [flow definition](https://github.com/react-community/react-navigation/blob/master/src/TypeDefinition.js#L32).\n\n### `render` function\nInvoked from `Transitioner.render()`. This function performs the actual rendering delegated from `Transitioner`. In this function, we can use the information included in the `transitionProps` and `prevTransitionProps` parameters to render scenes, create animations and handle gestures.\n\nThere are a few important properties of the `transitionProps` and `prevTransitionProps` parameters that are useful for the tasks mentioned above:\n\n- `scenes: Array<NavigationScene>` - a list of all available scenes\n- `position: NavigationAnimatedValue` - the progressive index of the transitioner's navigation state\n- `progress: NavigationAnimatedValue` - the value that represents the progress of the transition when navigation state changes from one to another. Its numberic value will range from 0 to 1.\n\nFor the complete list of properties of `NavigationTransitionProps`, check out its [flow definition](https://github.com/react-community/react-navigation/blob/master/src/TypeDefinition.js#L273).\n\n#### Examples\n\n`transitionProps.scenes` is the list of all available scenes. It is up to the implementor to determine how to lay them out on the screen. For example, we can render the scenes as a stack of cards like so:\n\n```jsx\n_render(transitionProps, prevTransitionProps) {\n  const scenes = transitionProps.scenes.map(scene => this._renderScene(transitionProps, scene));\n  return (\n    <View style={styles.stack}>\n      {scenes}\n    </View>\n  );\n}\n```\n\nWe can then use an `Animated.View` to animate the transition. To create necessary animated style properties, such as `opacity`, we can interpolate on `position` and `progress` values that come with `transitionProps`:\n\n```jsx\n_renderScene(transitionProps, scene) {\n  const { position } = transitionProps;\n  const { index } = scene;\n  const opacity = position.interpolate({\n    inputRange: [index-1, index, index+1],\n    outputRange: [0, 1, 0],\n  });\n  // The prop `router` is populated when we call `createNavigator`.\n  const Scene = this.props.router.getComponent(scene.route.routeName);\n  return (\n    <Animated.View style={{ opacity }}>\n      { Scene }\n    </Animated.View>\n  )\n}\n```\n\nThe above code creates a cross fade animation during transition.\n\nFor a comprehensive tutorial on how to create custom transitions, see this [blog post](http://www.reactnativediary.com/2016/12/20/navigation-experimental-custom-transition-1.html).\n\n#### Flow definition\n```js\nrender: (transitionProps: NavigationTransitionProps, prevTransitionProps: ?NavigationTransitionProps) => React.Element<*>,\n```\n\n#### Parameters\n- `transitionProps`: the current [NavigationTransitionProps](https://github.com/react-community/react-navigation/blob/master/src/TypeDefinition.js#L273) created from the current state and props\n- `prevTransitionProps`: the previous [NavigationTransitionProps](https://github.com/react-community/react-navigation/blob/master/src/TypeDefinition.js#L273) created from the previous state and props\n\n#### Returns\n- A ReactElement, which will be used to render the Transitioner component\n\n### `onTransitionStart` function\nInvoked when the transition animation is about to start.\n\n#### Flow definition\n```js\nonTransitionStart: (transitionProps: NavigationTransitionProps, prevTransitionProps: ?NavigationTransitionProps) => void,\n```\n#### Parameters\n- `transitionProps`: the current [NavigationTransitionProps](https://github.com/react-community/react-navigation/blob/master/src/TypeDefinition.js#L273) created from the current state and props\n- `prevTransitionProps`: the previous [NavigationTransitionProps](https://github.com/react-community/react-navigation/blob/master/src/TypeDefinition.js#L273) created from the previous state and props\n\n#### Returns\n- none.\n\n### `onTransitionEnd` function\nInvoked once the transition animation completes.\n\n#### Flow definition\n```js\nonTransitionEnd: () => void\n```\n#### Parameters\n- none.\n\n#### Returns\n- none.\n","api/views/Views":"# Views\n\nNavigation views are presentation components that take a [`router`](/docs/api/routers) and a [`navigation`](/docs/navigators/navigation-prop) prop, and can display several screens, as specified by the `navigation.state`.\n\nNavigation views are controlled React components that can present the current navigation state. They manage switching of screens, animations and gestures. They also present persistent navigation views such as tab bars and headers.\n\n## Built in Views\n\n- [CardStack](https://github.com/react-community/react-navigation/blob/master/src/views/CardStack.js) - Present a stack that looks suitable on any platform\n    + [Card](https://github.com/react-community/react-navigation/blob/master/src/views/Card.js) - Present one card from the card stack, with gestures\n    + [Header](https://github.com/react-community/react-navigation/blob/master/src/views/Header.js) - The header view for the card stack\n- [Tabs](https://github.com/react-community/react-navigation/blob/master/src/views/TabView) - A configurable tab switcher / pager\n- [Drawer](https://github.com/react-community/react-navigation/tree/master/src/views/Drawer) - A view with a drawer that slides from the left\n\n## [Transitioner](/docs/views/transitioner)\n\n`Transitioner` manages the animations during the transition and can be used to build fully custom navigation views. It is used inside the `CardStack` view. [Learn more about Transitioner here.](/docs/views/transitioner)\n","api/withNavigation":"\n# withNavigation\n\n[`withNavigation`](/src/views/withNavigation.js) is a Higher Order Component which passes the `navigation` prop into wrapped Component. It's useful when you cannnot pass the `navigation` prop into into the component directly, or don't want to pass it in case of a deeply nested child.\n\n## Example\n\n```js\nimport { Button } 'react-native';\nimport { withNavigation } from 'react-navigation';\n\nconst MyComponent = ({ to, navigation }) => (\n    <Button title={`navigate to ${to}`} onPress={() => navigation.navigate(to)} />\n);\n\nconst MyComponentWithNavigation = withNavigation(MyComponent);\n```\n","blog/2017-01-Introducing-React-Navigation":"# Introducing React Navigation for React Native\n_January 26, 2017_\n\nToday we're excited to introduce React Navigation, a flexible navigation library for React Native and web, including customizable views for React Native, routers for any platform, and navigators that make it super easy to get started. We aim to provide a simple and extensible solution which enables developers to share one navigation paradigm for all of their React apps.\n\n\n## Start Quick with pre-built Navigators\n\nA navigator is a React component with a static `.router` declared on it. To make it super easy to get started, React Navigation ships with a few navigator factories, pairing common views with routers.\n\nFor example, the provided `StackNavigator` makes it easy to use a `CardStack` view and a `StackRouter` together:\n\n```js\nconst MyApp = StackNavigator({\n  Home: {screen: HomeScreen},\n  Profile: {screen: ProfileScreen},\n});\n```\n\nEach of these screens are just React components, and they can easily set their own title:\n\n```js\nclass HomeScreen extends React.Component {\n  static navigationOptions = {\n    title: 'Home',\n  };\n  render() {\n    const { navigate } = this.props.navigation;\n    return (\n      <Button\n        onPress={() => navigate('Profile', { name: 'A' })}\n        title=\"Go to A's profile\"\n      />\n    );\n  }\n}\n```\n\nTo learn more, [continue with the getting started guide](/docs/intro).\n\n\n## Performant Views on React Native\n\nAnimations and gestures are critical for smooth navigation in a mobile app. React Navigation utilizes React Native's Animated library to provide 60fps animations that are driven from the native thread.\n\nThe views are designed to be highly extensible. For your app, you may want to build a custom modal, fork the stack header, or even utilize the underlying `<Transitioner>` component to build an entirely custom navigation presentation.\n\n\n## Routers for Every Platform\n\nIn React Navigation, routers manage the [relationship between actions, state, and URIs](/docs/routers/api). The routers are cross-platform, and there is example code for iOS, Android, and web. Several routers are included, including [`TabRouter`](/docs/routers/tab) and [`StackRouter`](/docs/routers/stack), and it is encouraged to [override their behavior as needed](/docs/routers).\n\nThe routers are composable and can be useful for structuring your app. A common navigation structure in iOS is to have an independent navigation stack for each tab, where all tabs can be covered by a modal. This is three layers of router: a card stack, within tabs, all within a modal stack. So unlike our experience on web apps, the navigation state of mobile apps is too complex to encode into a single URI. Routers in `react-navigation` map from URIs to navigation actions, which are then used to compute navigation state.\n\n\n## Future\n\nReact Navigation is born from the React Native community's need for an extensible yet easy-to-use navigation solution. It replaces and improves upon several navigation libraries in the ecosystem, including Ex-Navigation and React Native's Navigator and NavigationExperimental components.\n\nUntil the community lands on one navigation solution that works well on the web and React Native, we will forever be destined to re-invent navigation. We are extremely sensitive about the burden of change that accompanies a new navigation library, so we aim to provide a solution that will work long into the future. We are excited to support React Navigation for any platform, including cutting-edge frontiers like hybrid native apps, web server rendering, and ReactVR.\n\nThe first beta of React Navigation is available today on npm and GitHub, and you can [get started here](/docs/intro). We're excited to hear feedback from the React community, and together we still have a long way to go before our dream is realized. We'd love to see the community flourish with beautiful navigation views, custom router integrations, and more easy-to-use navigators. All of these individual contributions can work together seamlessly. If you have improvements for the built-in components, please [follow the contributors guide](/docs/guides/contributors) and dive right in!\n","guides/Common-Navigation-Spec":"# Common Navigation Spec\n\n### Introduction\n\nIt is useful to have “one standard way” to handle navigation in a React app. Unfortunately, we've learned that a single navigation library cannot be the right fit for every application. There is often a tradeoff between several useful features:\n\n* Simplicity\n* Supporting complex animations\n* Navigating between natively-implemented screens and JavaScript screens\n* Precise fidelity to the native UI controls\n* Default support for deep linking and the Android back button\n\nAlthough the React Native community will need more than one navigation library, we can make them work nicely together. The goal of this document is to specify a common API for navigation libraries. Consistency will make several things easier for React Native developers:\n\n* Combining multiple navigation libraries in one application\n* Switching out navigation libraries when requirements change\n* Learning navigation once, and applying that knowledge in different applications\n\nNavigation libraries don't have to implement all of this API - it's just a recommendation.\n\n(TODO: When we actually publish this spec, we should mention here what libraries are supporting it, what libraries will support it, and (link to?) how to migrate from other now-discouraged navigation libraries.)\n\n\n## Key Concepts\n\n#### Navigation Container\n\nThe parent component which hosts a navigation-aware component. It must provide the `navigation` prop, and usually uses the child component's static `router` to determine navigation state.\n\n#### Navigation-Aware Component\n\nA React component which can observe and initiate navigation in an app. It uses the navigation prop to see navigation state and request actions. It may expose a router to define navigation state and URI handling.\n\nThe card stack of your application may be a navigation-aware component. Also, one screen of your app that handles the Android back button is a navigation-aware component.\n\n#### Navigation State\n\nThe object that defines the navigation state of your component, passed in as a prop. A router can define the state, which optionally specifies the title and URI of the component.\n\n#### Action\n\nA JSON object used to request changes in the app's navigation state.\n\n#### Router\n\nDefines the navigation behavior of a component by defining navigation state as a function of actions, and allows URIs to be optionally converted into an action that can be handled.\n\n#### Navigator\n\nA navigation-aware component that hosts other navigation-aware components. Most navigators are expected to delegate all router logic, manage child navigation state, and pass up actions as they are dispatched.\n\n## Specification\n\n### The `navigation` prop\n\nThe navigation prop should be provided to components who need access to navigation. If provided, it must follow this interface:\n\n```javascript\ntype BackAction = {type: 'Navigation/BACK'};\ntype URIAction = {type: 'Navigation/URI', uri: string};\n\ninterface Navigation<S, A> {\n  dispatch(action: (A | BackAction | URIAction)): boolean;\n  state: S;\n}\n```\n\n#### navigation.state\n\nThe controlled navigation state prop, as requested by the parent.\n\n```javascript\nconst MyView = ({ navigation }) => {\n  switch (navigation.state.myRequestedView) {\n    case 'ViewA': return <ViewA />;\n    case 'ViewB': return <ViewB />;\n    default: return <OtherView />;\n  }\n}\n```\n\n#### navigation.dispatch(action)\n\nThe channel that a component can call to request navigation from its parent. When calling `dispatch`, you must provide an action object with a `type`. There are two special action types: 'Navigation/BACK' and 'Navigation/URI'.\n\n```javascript\nconst MyLink = ({ navigation }) => (\n  <Button onPress={() => {\n    navigation.dispatch({\n      type: 'MyNavigationRequest',\n      myParam: 42,\n    });\n  }>\n    Press me to navigate\n  </Button>\n);\n```\n\n\n### The static `router`\n\nA router object may be statically defined on your component. If defined, it must follow this interface:\n\n```javascript\ntype BackAction = {type: 'Navigation/BACK'};\ntype URIAction = {type: 'Navigation/URI', uri: string};\n\ninterface Router<S, A> {\n  getStateForAction(action: (A | BackAction | URIAction), lastState: ?S): ?S;\n  getActionForURI(uri: string): ?A;\n}\n```\n\nThe state and action types of the static router must match the state and action types associated with the navigation prop passed into the component.\n\n#### router.getStateForAction(action, lastState)\n\nThis function is defined on the static router and is used to define the expected navigation state.\n\n```javascript\nclass ScreenWithEditMode extends React.Component {\n  static router = {\n    getStateForAction: (action, prevState) => {\n      return { isEditing: true };\n    },\n  };\n  render() {\n    // this.props.navigation.state.isEditing === true\n    ...\n  }\n}\n```\n\n`getStateForAction` must **always** return a navigation state that can be rendered by the component when passed in as the `navigation.state` prop.\n\nIf null is returned, we are signaling that the previous navigation state has not changed, but the action is handled. This is usually used in cases where the action is being swallowed.\n\n\n#### router.getActionForURI(uri)\n\nReturn an action if a URI can be handled, otherwise return `null`\n\n\n\n### Special Actions\n\nThere are two special actions that can be fired into `navigation.dispatch` and can be handled by your `router.getStateForAction`.\n\n#### Back Action\n\nThis action means the same thing as an Android back button press.\n\n```\ntype BackAction = { type: 'Navigation/BACK' };\n```\n\n#### URI Open Action\n\nUsed to request the enclosing app or OS to open a link at a particular URI. If it is a web URI like `http` or `https`, the app may open a WebView to present the page. Or the app may open the URI in a web browser. In some cases, an app may choose to block a URI action or handle it differently.\n\n```\ntype URIAction = { type: 'Navigation/URI', uri: string };\n```\n\n\n### Special Navigation State\n\nThe state defined by `router.getStateForAction` can contain special navigation properties that may be relevant to your app. The title and current URI of a component may change over time, and the parent often needs to observe the behavior.\n\n#### `state.title`\n\nIf the navigation state contains 'title', it will be used as the title for the given component. This is relevant for top-level components on the web to update the browser title, and is relevant in mobile apps where a title is shown in the header.\n\n#### `state.uri`\n\nA URI can also be put in `state.uri`, which will signal to the parent how it may be possible to deep link into a similar navigation state. In web apps, this will be used to keep the URI bar in sync with the current navigation state of the app.\n\n\n## Use Cases\n\n### \"Block the Android back button on one screen of my app\"\n\nTo block the Android back button:\n\n```\nclass Foo extends React.Component {\n  static router = {\n    getStateForAction(action, prevState = {}) {\n      if (action.type === 'Navigation/BACK') return null;\n      else return prevState;\n    },\n  };\n  render() {\n    ...\n```\n\nBecause we return null, we signal to our container that the action has been handled but the state does not change. The parent should not handle the back behavior at this point, and nothing should be re-rendered.\n\n### \"Link deeply into one screen of my app\"\n\n```\nclass Foo extends React.Component {\n  static router = {\n    getStateForAction(action, prevState = {deep: false}) {\n      if (action.type === 'GoDeep') return { deep: true };\n      else return prevState;\n    },\n    getActionForURI(uri) {\n      if (uri === 'myapp://foo')\n        return {type: 'Go'};\n      else if (uri === 'myapp://foo_deep')\n        return {type: 'GoDeep'};\n      return null;\n    },\n  };\n  render() {\n    // this.props.navigation.state.deep may be true or false\n    ...\n```\n\nBased on the state URI we may decide to return an action. If an action is returned, `getStateForAction` is expected to output the correct state for a deep link.\n\n## Reference Implementations\n\nA library to that helps easily produce navigation-aware components: https://github.com/react-community/react-navigation . (Also uses a HOC to provide navigation containers when needed.)\n\nA simple navigation container: https://gist.github.com/ericvicenti/77d190e2ec408012255937400e34bdb1\n\nA web implementation of a navigation container: https://gist.github.com/ericvicenti/55bef95fcd8558029a3bae8483baea6c\n","guides/Contributors":"# Contributors Guide\n\n## Environment\n\nReact navigation was initially developed on macOS 10.12, with node 7+, and react-native v0.39+. Please open issues when uncovering problems in different environments.\n\n## Development\n\n### 0. Basic Install\n\n```\ngit clone git@github.com:react-community/react-navigation.git\ncd react-navigation\nnpm install\n```\n\n### 1. Run the native playground\n\n```\ncd examples/NavigationPlayground\nnpm install\ncd ../..\nnpm start\n\n# In a seperate terminal tab:\nnpm run run-playground-android\nnpm run run-playground-ios\n```\n\n### 2. Run the website\n\nFor development mode and live-reloading:\n\n```\ncd website\nnpm install\nnpm run start\n```\n\nTo run the website in production mode with server rendering:\n\n```\nnpm run prod\n```\n\n### 3. Run tests, run flow\n\n```\njest\nflow\n```\n\nTests must pass for your changes to be accepted and merged.\n\nFlow is not yet passing, but your code should be flow checked and we expect that your changes do not introduce any flow errors.\n\n\n### 4. Developing Docs\n\nThe docs are indexed in [App.js](https://github.com/react-community/react-navigation/blob/master/website/src/App.js), where all the pages are declared alongside the titles. To test the docs, follow the above instructions for running the website. Changing existing markdown files should not require any testing.\n\nThe markdown from the `docs` folder gets generated and dumped into a json file as a part of the build step. To see updated docs appear in the website, re-run the build step by running `npm run build-docs` from the `react-navigation` root folder.\n\n\n## Submitting Contributions\n\n### New views or unique features\n\nOften navigation needs are specific to certain apps. If your changes are unique to your app, you may want to fork the view or router that has changed. You can keep the source code in your app, or publish it on npm as a `react-navigation` compatible view or router.\n\nThis library is intended to include highly standard and generic navigation patterns.\n\n### Major Changes\n\nBefore embarking on any major changes, please file an issue describing the suggested change and motivation. We may already have thought about it and we want to make sure we all are on the same page before starting on any big changes.\n\n### Minor Bugfixes\n\nSimple bug fixes are welcomed in pull requests! Please check for duplicate PRs before posting.\n","guides/Custom-Navigators":"# Custom Navigators\n\nA navigator is any React component that has a [router](/docs/routers/) on it. Here is a basic one, which uses the [router's API](/docs/routers/api) to get the active component to render:\n\n```js\nclass MyNavigator extends React.Component {\n  static router = MyRouter;\n  render() {\n    const { state, dispatch } = this.props.navigation;\n    const { routes, index } = state;\n\n    // Figure out what to render based on the navigation state and the router:\n    const Component = MyRouter.getComponentForState(state);\n\n    // The state of the active child screen can be found at routes[index]\n    let childNavigation = { dispatch, state: routes[index] };\n    // If we want, we can also tinker with the dispatch function here, to limit\n    // or augment our children's actions\n\n    // Assuming our children want the convenience of calling .navigate() and so on,\n    // we should call addNavigationHelpers to augment our navigation prop:\n    childNavigation = addNavigationHelpers(childNavigation);\n\n    return <Component navigation={childNavigation} />;\n  }\n}\n```\n\n## Navigation Prop\n\nThe navigation prop passed down to a navigator only includes `state` and `dispatch`. This is the current state of the navigator, and an event channel to send action requests.\n\nAll navigators are controlled components: they always display what is coming in through `props.navigation.state`, and their only way to change the state is to send actions into `props.navigation.dispatch`.\n\nNavigators can specify custom behavior to parent navigators by [customizing their router](/docs/routers/). For example, a navigator is able to specify when actions should be blocked by returning null from `router.getStateForAction`. Or a navigator can specify custom URI handling by overriding `router.getActionForPathAndParams` to output a relevant navigation action, and handling that action in `router.getStateForAction`.\n\n### Navigation State\n\nThe navigation state that is passed into a navigator's `props.navigation.state` has the following structure:\n\n```\n{\n  index: 1, // identifies which route in the routes array is active\n  routes: [\n    {\n      // Each route needs a name, which routers will use to associate each route\n      // with a react component\n      routeName: 'MyRouteName',\n\n      // A unique id for this route, used to keep order in the routes array:\n      key: 'myroute-123',\n\n      // Routes can have any additional data. The included routers have `params`\n      ...customRouteData,\n    },\n    ...moreRoutes,\n  ]\n}\n```\n\n### Navigation Dispatchers\n\nA navigator can dispatch navigation actions, such as 'Go to a URI', 'Go back'.\n\nThe dispatcher will return `true` if the action was successfully handled, otherwise `false`.\n\n## API for building custom navigators\n\nTo help developers implement custom navigators, the following utilities are provided with React Navigation:\n\n### `createNavigator`\n\nThis utility combines a [router](/docs/routers/) and a [navigation view](/docs/views/) together in a standard way:\n\n```js\nconst MyApp = createNavigator(MyRouter)(MyView);\n```\n\nAll this does behind the scenes is:\n\n```js\nconst MyApp = ({ navigation }) => (\n  <MyView router={MyRouter} navigation={navigation} />\n);\nMyApp.router = MyRouter;\n```\n\n### `addNavigationHelpers`\n\nTakes in a bare navigator navigation prop with `state` and `dispatch`, and augments it with all the various functions in a screen navigation prop, such as `navigation.navigate()` and `navigation.goBack()`. These functions are simply helpers to create the actions and send them into `dispatch`.\n\n### `createNavigationContainer`\n\nIf you want your navigator to be usable as a top-level component, (without a navigation prop being passed in), you can use `createNavigationContainer`. This utility will make your navigator act like a top-level navigator when the navigation prop is missing. It will manage the app state, and integrate with app-level nav features, like handling incoming and outgoing links, and Android back button behavior.\n","guides/Customizing-Navigation":"## Customizing Navigation Views\n\nModify the presentation of navigation, including styles, animations and gestures.\n\n## Customizing Routers\n\nBuilding a custom router allows you to change the navigation logic of your component, manage navigation state, and define behavior for URIs.\n\n\nA router can be defined like this:\n\n```\nclass MyNavigationAwareComponent extends React.Component {\n\n    static router = {\n\n        // Defines the navigation state for a component:\n        getStateForAction: (action: {type: string}, lastState?: any) => {\n            const state = lastState = { myMode: 'default' };\n            if (action.type === 'MyAction') {\n                return { myMode: 'action' };\n            } else if (action.type === NavigationActions.BACK) {\n                return { myMode: 'blockBackButton' };\n            } else {\n                return state;\n            }\n        },\n\n        // Defines if a component can handle a particular URI.\n        // If it does, return an action to be passed to `getStateForAction`\n\n        getActionForURI: (uri: string) => {\n            if (uri === 'myapp://myAction') {\n                return { type: 'MyAction' };\n            }\n            return null;\n        },\n\n    };\n\n    render() {\n        // render something based on this.props.navigation.state\n        ...\n    }\n\n    onButtonPress = () => {\n        this.props.navigation.dispatch({ type: 'MyAction' });\n    };\n\n    ...\n\n}\n```\n","guides/Deep-Linking":"# Deep Linking\n\nIn this guide we will set up our app to handle external URIs. Let's start with the SimpleApp that [we created in the getting started guide](/docs/intro).\n\nIn this example, we want a URI like `mychat://chat/Taylor` to open our app and link straight into Taylor's chat page.\n\n## Configuration\n\nPreviously, we had defined a navigator like this:\n\n```js\nconst SimpleApp = StackNavigator({\n  Home: { screen: HomeScreen },\n  Chat: { screen: ChatScreen },\n});\n```\n\nWe want paths like `chat/Taylor` to link to a \"Chat\" screen with the `user` passed as a param. Let's re-configure our chat screen with a `path` that tells the router what relative path to match against, and what params to extract. This path spec would be `chat/:user`.\n\n```js\nconst SimpleApp = StackNavigator({\n  Home: { screen: HomeScreen },\n  Chat: {\n    screen: ChatScreen,\n    path: 'chat/:user',\n  },\n});\n```\n\n\n### URI Prefix\n\nNext, let's configure our navigation container to extract the path from the app's incoming URI. When configuring a top-level navigator, we can provide `containerOptions`:\n\n```js\nconst SimpleApp = StackNavigator({\n  ...\n}, {\n  containerOptions: {\n    // on Android, the URI prefix typically contains a host in addition to scheme\n    URIPrefix: Platform.OS == 'android' ? 'mychat://mychat/' : 'mychat://',\n  },\n});\n```\n\n## iOS\n\nLet's configure the native iOS app to open based on the `mychat://` URI scheme.\n\nIn `SimpleApp/ios/SimpleApp/AppDelegate.m`:\n\n```\n// Add the header at the top of the file:\n#import <React/RCTLinkingManager.h>\n\n// Add this above the `@end`:\n- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url\n  sourceApplication:(NSString *)sourceApplication annotation:(id)annotation\n{\n  return [RCTLinkingManager application:application openURL:url\n                      sourceApplication:sourceApplication annotation:annotation];\n}\n```\n\nIn Xcode, open the project at `SimpleApp/ios/SimpleApp.xcodeproj`. Select the project in sidebar and navigate to the info tab. Scroll down to \"URL Types\" and add one. In the new URL type, set the identifier and the url scheme to your desired url scheme.\n\n![Xcode project info URL types with mychat added](/assets/xcode-linking.png)\n\nNow you can press play in Xcode, or re-build on the command line:\n\n```sh\nreact-native run-ios\n```\n\nTo test the URI in iOS, open safari and type `mychat://chat/Taylor`.\n\n## Android\n\nTo configure the external linking in Android, you can create a new intent in the manifest.\n\nIn `SimpleApp/android/app/src/main/AndroidManifest.xml`, add the new `VIEW` type `intent-filter` inside the `MainActivity` entry:\n\n```\n<intent-filter>\n    <action android:name=\"android.intent.action.VIEW\" />\n    <category android:name=\"android.intent.category.DEFAULT\" />\n    <category android:name=\"android.intent.category.BROWSABLE\" />\n    <data android:scheme=\"mychat\"\n          android:host=\"mychat\" />\n</intent-filter>\n```\n\nNow, re-install the app:\n\n```sh\nreact-native run-android\n```\n\nTo test the intent handling in Android, run the following:\n\n```\nadb shell am start -W -a android.intent.action.VIEW -d \"mychat://mychat/chat/Taylor\" com.simpleapp\n```\n\n```phone-example\nlinking\n```\n","guides/Guide-Headers":"# Configuring the Header\n\nIn the previous example, we created a StackNavigator to display several screens in our app.\n\n\nWhen navigating to a chat screen, we can specify params for the new route by providing them to the navigate function. In this case, we want to provide the name of the person on the chat screen:\n\n```js\nthis.props.navigation.navigate('Chat', { user:  'Lucy' });\n```\n\nThe `user` param can be accessed from the chat screen:\n\n```js\nclass ChatScreen extends React.Component {\n  render() {\n    const { params } = this.props.navigation.state;\n    return <Text>Chat with {params.user}</Text>;\n  }\n}\n```\n\n### Setting the Header Title\n\nNext, the header title can be configured to use the screen param:\n\n```js\nclass ChatScreen extends React.Component {\n  static navigationOptions = {\n    // // Title may be a simple string:\n    // title: 'Hello',\n\n    // Or the title string may be a function of the navigation prop:\n    title: ({ state }) => `Chat with ${state.params.user}`\n  };\n  ...\n}\n```\n\n```phone-example\nbasic-header\n```\n\n\n### Adding a Right Button\n\nThen we can add a [`header` navigation option](/docs/navigators/navigation-options#Stack-Navigation-Options) that allows us to add a custom right button:\n\n```js\nstatic navigationOptions = {\n  header: {\n    right: <Button title=\"Info\" />,\n  },\n  ...\n```\n\n```phone-example\nheader-button\n```\n\nJust like `title`, the `header` option can be defined as a function of the [navigation prop](/docs/navigators/navigation-prop). Let's render a different button based on the route params, and set up the button to call `navigation.setParams` when pressed.\n\n```js\nstatic navigationOptions = {\n  title: ({ state }) => {\n    if (state.params.mode === 'info') {\n      return `${state.params.user}'s Contact Info`;\n    }\n    return `Chat with ${state.params.user}`;\n  },\n  header: ({ state, setParams }) => {\n    // The navigation prop has functions like setParams, goBack, and navigate.\n    let right = (\n      <Button\n        title={`${state.params.user}'s info`}\n        onPress={() => setParams({ mode: 'info' })}\n      />\n    );\n    if (state.params.mode === 'info') {\n      right = (\n        <Button\n          title=\"Done\"\n          onPress={() => setParams({ mode: 'none' })}\n        />        \n      );\n    }\n    return { right };\n  },\n  ...\n```\n\nNow, the header can interact with the screen route/state:\n\n```phone-example\nheader-interaction\n```\n\nTo see the rest of the header options, see the [navigation options document](/docs/navigators/navigation-options#Stack-Navigation-Options).\n","guides/Guide-Intro":"# Hello Mobile Navigation\n\nLet's use React Navigation to build a simple chat application for Android and iOS.\n\n## Setup and Installation\n\nFirst, make sure you're [all set up to use React Native](http://facebook.github.io/react-native/docs/getting-started.html). Next, create a new project and add `react-navigation`:\n\n\n```sh\n# Create a new React Native App\nreact-native init SimpleApp\ncd SimpleApp\n\n# Install the latest version of react-navigation from npm\nnpm install --save react-navigation\n\n# Run the new app\nreact-native run-android # or:\nreact-native run-ios\n```\n\nVerify that you can successfully see the bare sample app run on iOS and/or Android:\n\n```phone-example\nbare-project\n```\n\nWe want to share code on iOS and Android, so lets delete the contents of `index.ios.js` and `index.android.js` and replace it with `import './App';`.\n\nNow lets create the new file for our app implementation, `App.js`.\n\n## Introducing Stack Navigator\n\nFor our app, we want to use the `StackNavigator` because we want a conceptual 'stack' navigation, where each new screen is put on the top of the stack and going back removes a screen from the top of the stack. Let's start with just one screen:\n\n```js\nimport React from 'react';\nimport {\n  AppRegistry,\n  Text,\n} from 'react-native';\nimport { StackNavigator } from 'react-navigation';\n\nclass HomeScreen extends React.Component {\n  static navigationOptions = {\n    title: 'Welcome',\n  };\n  render() {\n    return <Text>Hello, Navigation!</Text>;\n  }\n}\n\nconst SimpleApp = StackNavigator({\n  Home: { screen: HomeScreen },\n});\n\nAppRegistry.registerComponent('SimpleApp', () => SimpleApp);\n```\n\nThe `title` of the screen is configurable on the [static `navigationOptions`](/docs/navigators/navigation-options), where many options can be set to configure the presentation of the screen in the navigator.\n\nNow the same screen should appear on both iPhone and Android apps:\n\n```phone-example\nfirst-screen\n```\n\n## Adding a New Screen\n\nIn our `App.js` file, let's add a new screen called `ChatScreen`:\n\n```js\nclass ChatScreen extends React.Component {\n  static navigationOptions = {\n    title: 'Chat with Lucy',\n  };\n  render() {\n    return (\n      <View>\n        <Text>Chat with Lucy</Text>\n      </View>\n    );\n  }\n}\n```\n\nWe can then add a button to our `HomeScreen` component that links to `ChatScreen` using the `routeName` `Chat`.\n\n```js\nclass HomeScreen extends React.Component {\n  static navigationOptions = {\n    title: 'Welcome',\n  };\n  render() {\n    const { navigate } = this.props.navigation;\n    return (\n      <View>\n        <Text>Hello, Chat App!</Text>\n        <Button\n          onPress={() => navigate('Chat')}\n          title=\"Chat with Lucy\"\n        />\n      </View>\n    );\n  }\n}\n```\n\nWe're using the navigate function from the [screen navigation prop](/docs/navigators/navigation-prop) to go to `ChatScreen`. But that won't work until we add this to our `StackNavigator` like so:\n\n```js\nconst SimpleApp = StackNavigator({\n  Home: { screen: HomeScreen },\n  Chat: { screen: ChatScreen },\n});\n```\n\nNow you can navigate to your new screen, and go back:\n\n```phone-example\nfirst-navigation\n```\n\n## Passing params\n\nHardcoding a name into the `ChatScreen` isn't ideal. It'd be more useful if we could pass a name to be rendered instead, so let's do that.\n\nIn addition to specifying the target `routeName` in the navigate function, we can pass params that will be put into the new route. First, we'll edit our `HomeScreen` component to pass a `name` param into the route.\n\n```js\nclass HomeScreen extends React.Component {\n  static navigationOptions = {\n    title: 'Welcome',\n  };\n  render() {\n    const { navigate } = this.props.navigation;\n    return (\n      <View>\n        <Text>Hello, Chat App!</Text>\n        <Button\n          onPress={() => navigate('Chat', { user: 'Lucy' })}\n          title=\"Chat with Lucy\"\n        />\n      </View>\n    );\n  }\n}\n```\n\nWe can then edit our `ChatScreen` component to display the `name` param that was passed in through the route:\n\n```js\nclass ChatScreen extends React.Component {\n  static navigationOptions = {\n    // Nav options can be defined as a function of the navigation prop:\n    title: ({ state }) => `Chat with ${state.params.user}`,\n  };\n  render() {\n    // The screen's current route is passed in to `props.navigation.state`:\n    const { params } = this.props.navigation.state;\n    return (\n      <View>\n        <Text>Chat with {params.user}</Text>\n      </View>\n    );\n  }\n}\n```\n\nNow you can see the name when you navigate to the Chat screen. Try changing the `name` param in `HomeScreen` and see what happens!\n\n```phone-example\nfirst-navigation\n```\n","guides/Guide-Nested":"# Nesting Navigators\n\nIt is common in mobile apps to compose various forms of navigation. The routers and navigators in React Navigation are composable, which allows you to define a complicated navigation structure for your app.\n\nFor our chat app, we want to put several tabs on the first screen, to view recent chat threads or all contacts.\n\n## Introducing Tab Navigator\n\nLets create a new `TabNavigator` in our `App.js`:\n\n```js\nclass RecentChatsScreen extends React.Component {\n  render() {\n    return <Text>List of recent chats</Text>\n  }\n}\n\nclass AllContactsScreen extends React.Component {\n  render() {\n    return <Text>List of all contacts</Text>\n  }\n}\n\nconst MainScreenNavigator = TabNavigator({\n  Recent: { screen: RecentChatsScreen },\n  All: { screen: AllContactsScreen },\n});\n```\n\nIf the `MainScreenNavigator` was rendered as the top-level navigator component, it would look like this:\n\n```phone-example\nsimple-tabs\n```\n\n\n\n## Nesting a Navigator in a screen\n\nWe want these tabs to be visible in the first screen of the app, but new screens in the stack should cover the tabs.\n\nLets add our tabs navigator as a screen in our top-level `StackNavigator` that we set up in the [previous step](/docs/intro/).\n\n```js\nconst SimpleApp = StackNavigator({\n  Home: { screen: MainScreenNavigator },\n  Chat: { screen: ChatScreen },\n});\n```\n\nBecause `MainScreenNavigator` is being used as a screen, we can give it `navigationOptions`:\n\n```js\nMainScreenNavigator.navigationOptions = {\n  title: 'My Chats',\n};\n```\n\nLets also add a button to each tab that links to a chat:\n\n```js\n<Button\n  onPress={() => this.props.navigation.navigate('Chat', { user: 'Lucy' })}\n  title=\"Chat with Lucy\"\n/>\n```\n\nNow we have put one navigator inside another, and we can `navigate` between navigators:\n\n```phone-example\nnested\n```\n","guides/Hybrid-Navigation":"## Common React Navigation API - Hybrid Integration\n\nThis is a purely speculative API that demonstrates how it may be possible to integrate the [JS navigation API](./Common-Navigation-Spec.md) in a hybrid app.\n\n## Setting up a screen\n\nIt should be possible to register new screens from JS into native. In your main bundle:\n\n```\nconst HybridNavigationModule = require('NativeModules').HybridNavigation;\n\nHybridNavigationModule.registerScreens([\n  {\n    type: 'Marketplace',\n    screen: MarketplaceScreen,\n  },\n  {\n  \ttype: 'Product',\n  \tscreen: ProductScreen,\n  },\n]);\n```\n\n## Linking to JS\n\nNow, your native code can open a react screen by type name:\n\n```\n// please pretend this is Obj-C or Java syntax:\nCoreHybridNavigation.openReactScreen('Profile', {id: 123});\n```\n\n## Linking to Native\n\nIf JS product code wants to request navigation to a screen that may *or may not* be in native, it can do this:\n\n```\nconst MarketplaceScreen = ({ navigation }) => (\n  <View>\n    <Button onPress={() => navigation.dispatch({\n      type: 'Product',\n      id: 42,\n    })}>\n      See product 42\n    </Button>\n  </View>\n);\n```\n\nInside the infra:\n\n```\nclass InfraScreen extends React.Component {\n  constructor() {\n    const {initURI, type} = this.props;\n    const ScreenView = ScreenRegistry[type].screen;\n    const router = ScreenView.router;\n    const deepLinkAction = router.getActionForURI(initURI);\n    const initAction = deepLinkAction || {type: 'init'}\n    const nav = router.getStateForAction(initAction);\n    this.state = {\n      nav,\n    };\n    HybridNavigationModule.setNavOptions(this.state.nav);\n  }\n  componentWillUpdate() {\n    HybridNavigationModule.setNavOptions(this.state.nav);\n  }\n  dispatch = (action) => {\n    const {type} = this.props;\n    const ScreenView = ScreenRegistry[type].screen;\n    const {getStateForAction} = ScreenView.router;\n    const newNavState = getStateForAction(action, this.state.nav);\n    if (newNavState !== this.state.nav) {\n      this.setState({ nav: newNavState });\n      return true;\n    }\n    if (action.type === 'URI') {\n      HybridNavigationModule.openURI(action.uri);\n      return true;\n    }\n    if (action.type === NavigationActions.BACK) {\n      HybridNavigationModule.goBack();\n      return true;\n    }\n    HybridNavigationModule.openAction(action);\n    return true;\n  }\n  render() {\n    const {type} = this.props;\n    const ScreenView = ScreenRegistry[type].screen;\n    const navigation = {\n      dispatch: this.dispatch,\n      state: this.state.nav,\n    };\n    return <ScreenView navigation={navigation} />;\n  }\n}\n```\n\n## Setting title\n\n```\nMarketplaceScreen.router = {\n  getStateForAction(action, lastState) {\n    return lastState || {title: 'Marketplace Home'};\n  },\n};\n```\nA HOC could be used to make this feel more elegant.\n\n\n## Disabling/Enabling the right button\n\n```\nconst TestScreen = ({ navigation }) => (\n  <View>\n    <Button onPress={() => navigation.dispatch({\n      type: 'ToggleMyButtonPressability',\n    })}>\n      {navigation.state.rightButtonEnabled ? 'Disable' : 'Enable'} right button\n    </Button>\n    <Text>Pressed {navigation.state} times</Text>\n  </View>\n);\nTestScreen.router = {\n  getStateForAction(action, lastState = {}) {\n    let state = lastState || {\n      rightButtonEnabled: true,\n      rightButtonTitle: 'Tap Me',\n      pressCount: 0,\n    };\n    if (action.type === 'ToggleMyButtonPressability') {\n      state = {\n        ...state,\n        rightButtonEnabled: !state.rightButtonEnabled,\n      };\n    } else if (action.type === 'RightButtonPress') {\n      state = {\n        ...state,\n        pressCount: state.pressCount + 1,\n      };\n    }\n    return state;\n  },\n};\n```\n\n\n## Before JS starts\n\nA JSON file could be defined for native to consume before JS spins up:\n\n```\n{\n  \"screens\": [\n    {\n      \"type\": \"Profile\",\n      \"path\": \"/users/:id?name=:name\",\n      \"params\": {\n        \"name\": \"string\",\n        \"id\": \"number\"\n      },\n      \"title\": \"%name%' s Profile\",\n      \"rightButtonTitle\": \"Message %name%\"\n    },\n    {\n      ...\n    }\n  ]\n}\n```\n\nThis seems like a pain to set up, so we can statically analyze our JS and autogenerate this JSON! If the JS in an app changes, there could be a way for JS to report the new routing configuration to native for use on the next cold start.\n","guides/Redux-Integration":"# Redux Integration\n\nTo handle your app's navigation state in redux, you can pass your own `navigation` prop to a navigator. Your navigation prop must provide the current state, as well as access to a dispatcher to handle navigation options.\n\nWith redux, your app's state is defined by a reducer. Each navigation router effectively has a reducer, called `getStateForAction`. The following is a minimal example of how you might use navigators within a redux application:\n\n```\nimport { addNavigationHelpers } from 'react-navigation';\n\nconst AppNavigator = StackNavigator(AppRouteConfigs);\n\nconst navReducer = (state, action) => {\n  const newState = AppNavigator.router.getStateForAction(action, state);\n  return newState || state;\n};\n\nconst appReducer = combineReducers({\n  nav: navReducer,\n  ...\n});\n\n@connect(state => ({\n  nav: state.nav,\n}))\nclass AppWithNavigationState extends React.Component {\n  render() {\n    return (\n      <AppNavigator navigation={addNavigationHelpers({\n        dispatch: this.props.dispatch,\n        state: this.props.nav,\n      })} />\n    );\n  }\n}\n\nconst store = createStore(appReducer);\n\nclass App extends React.Component {\n  render() {\n    return (\n      <Provider store={store}>\n        <AppWithNavigationState />\n      </Provider>\n    );\n  }\n}\n```\n\nOnce you do this, your navigation state is stored within your redux store, at which point you can fire navigation actions using your redux dispatch function.\n\nKeep in mind that when a navigator is given a `navigation` prop, it relinquishes control of its internal state. That means you are now responsible for persisting its state, handling any deep linking, integrating the back button, etc.\n\nNavigation state is automatically passed down from one navigator to another when you nest them. Note that in order for a child navigator to receive the state from a parent navigator, it should be defined as a `screen`.\n\nApplying this to the example above, you could instead define `AppNavigator` to contain a nested `TabNavigator` as follows:\n\n```js\nconst AppNavigator = StackNavigator({\n  Home: { screen: MyTabNavigator },\n});\n```\n\nIn this case, once you `connect` `AppNavigator` to Redux as is done in `AppWithNavigationState`, `MyTabNavigator` will automatically have access to navigation state as a `navigation` prop.\n","guides/Screen-Nav-Options":"\n# Screen Navigation Options\n\nEach screen can configure several aspects about how it gets presented in parent navigators.\n\n#### Two Ways to specify each option\n\n**Static configuration:** Each navigation option can either be directly assigned:\n\n```js\nclass MyScreen extends React.Component {\n  static navigationOptions = {\n    title: 'Great',\n  };\n  ...\n```\n\n**Dynamic Configuration**\n\nOr, each option can be a function that takes the following arguments, and returns the value of the option.\n\n- `navigation` - the [navigation prop](/docs/navigators/navigation-prop) for the screen, with the screen's route at `navigation.state`\n- `childRouter` - The child router, if the screen is a navigator\n\n```js\nclass ProfileScreen extends React.Component {\n  static navigationOptions = {\n    title: (navigation, childRouter) => {\n      return navigation.state.params.name + \"'s Profile!\";\n    },\n  };\n  ...\n```\n\n#### Generic Navigation Options\n\nThe `title` navigation option is generic between every navigator. It is used to set the title string for a given screen.\n\n```js\nclass MyScreen extends React.Component {\n  static navigationOptions = {\n    title: 'Great',\n  };\n  ...\n```\n\nUnlike the other nav options which are only utilized by the navigator view, the title option can be used by the environment to update the title in the browser window or app switcher.\n\n#### Default Navigation Options\n\nIt's very common to define `navigationOptions` on a screen, but sometimes it is useful to define `navigationOptions` on a navigator too. \n\nImagine the following scenario: \nYour `TabNavigator` represents one of the screens in the app, and is nested within a top-level `StackNavigator`:\n\n```\nStackNavigator:\n  - route1: A screen\n  - route2: A TabNavigator\n```\n\nNow, when `route2` is active, you would like to hide the header. It's easy to hide the header for `route1`, and it should also be easy to do it for `route2`. This is what Default Navigation Options are for - they are simply `navigationOptions` set on a navigator:\n\n```js\nTabNavigator({\n  profile: ProfileScreen,\n  ...\n}, {\n  navigationOptions: {\n     header: {\n       visible: false,\n     },\n   },\n });\n```\n\nNote that you can still decide to **also** specify the `navigationOptions` on the screens at the leaf level - e.g.  the `ProfileScreen` above. The `navigationOptions` from the screen will be merged key-by-key with the default options coming from the navigator. Whenever both the navigator and screen define the same option (e.g. `header`), the screen wins. Therefore, you could make the header visible again when `ProfileScreen` is active.\n\n**Extending defaults:** In order to extend default config with screen-specific properties instead of overriding it, you configure an option like this:\n \n```js\nclass ProfileScreen extends React.Component {\n  static navigationOptions = {\n    header: (navigation, defaultHeader) => ({\n      ...defaultHeader,\n      visible: true,\n    }),\n  }\n  ...\n}\n```\n \nThe 2nd argument passed to the function are the default values for the `header` as defined on the navigator.\n\n\n## Tab Navigation Options\n\n```js\nclass TabScreen extends React.Component {\n\n  static navigationOptions = {\n    tabBar: ({ state }) => ({\n      label: 'Tab Label',\n      icon: ({ tintColor }) => (\n        <Image\n          source={require('./tab-icon.png')}\n          style={[styles.icon, {tintColor: tintColor}]}\n        />\n      ),\n      visible: true\n    }),\n  };\n\n};\n```\n\n- `label` - can be string or react component\n- `icon` - function that returns icon component\n- `visible` - true or false to show or hide the tab bar, if not set then defaults to true\n\n## Stack Navigation Options\n\nComing Soon\n","guides/Screen-Navigation-Prop":"\n# Screen Navigation Prop\n\nEach screen in your app will recieve a navigation prop, which contains the following:\n\n\n## `navigate` - Link to other screens\n\nCall this to link to another screen in your app. Takes the following arguments:\n\n- `routeName` - A destination routeName that has been registered somewhere in the app's router\n- `params` - Params to merge into the destination route\n- `action` - (advanced) The sub-action to run in the child router, if the screen is a navigator.\n\n```js\nclass HomeScreen extends React.Component {\n  render() {\n    const {navigate} = this.props.navigation;\n\n    return (\n      <View>\n        <Text>This is the home screen of the app</Text>\n        <Button\n          onPress={() => navigate('Profile', {name: 'Brent'})}\n          title=\"Go to Brent's profile\"\n        />\n      </View>\n     )\n   }\n}\n```\n\n## `state` - The screen's current state/route\n\nA screen has access to its route via `this.props.navigation.state`. Each will contain:\n\n- `routeName` - the name of the route config in the router\n- `key` - a unique identifier used to sort routes\n- `params` - an optional object of string options for this screen\n\n```js\nclass ProfileScreen extends React.Component {\n  render() {\n    const {state} = this.props.navigation;\n    // state.routeName === 'Profile'\n    return (\n      <Text>Name: {state.params.name}</Text>\n    );\n  }\n}\n```\n\n\n## `setParams` - Make changes to route params\n\nFiring the `setParams` action allows a screen to change the params in the route, which is useful for updating the header buttons and title.\n\n```js\nclass ProfileScreen extends React.Component {\n  render() {\n    const {setParams} = this.props.navigation;\n    return (\n      <Button\n        onPress={() => setParams({name: 'Lucy'})}\n        title=\"Set title name to 'Lucy'\"\n      />\n     )\n   }\n}\n```\n\n## `goBack` - Close the active screen and move back\n\n```js\nclass HomeScreen extends React.Component {\n  render() {\n    const {goBack} = this.props.navigation;\n    return (\n      <View>\n        <Button\n          onPress={() => goBack()}\n          title=\"Go back from this HomeScreen\"\n        />\n        <Button\n          onPress={() => goBack(null)}\n          title=\"Go back anywhere\"\n        />\n        <Button\n          onPress={() => goBack('screen-123')}\n          title=\"Go back from screen-123\"\n        />\n      </View>\n     )\n   }\n}\n```\n\nOptionally provide a key, which specifies the route to go back from. By default, goBack will close the route that it is called from. If the goal is to go back *anywhere*, without specifying what is getting closed, call `.goBack(null);`\n\n\n## `dispatch` - Send an action to the router\n\nUse dispatch to send any navigation action to the router. The other navigation functions use dispatch behind the scenes.\n\nNote that if you want to dispatch react-navigation actions you should use the action creators provided in this library.\n\nThe following actions are supported:\n\n### Navigate\n```js\nimport { NavigationActions } from 'react-navigation'\n\nconst navigationAction = NavigationActions.navigate({\n  routeName: 'Profile',\n  params: {},\n\n  // navigate can have a nested navigate action that will be run inside the child router\n  action: NavigationActions.navigate({ routeName: 'SubProfileRoute'})\n})\nthis.props.navigation.dispatch(navigationAction)\n\n```\n\n\n### Reset\n\nThe `Reset` action wipes the whole navigation state and replaces it with the result of several actions.\n\n```js\nimport { NavigationActions } from 'react-navigation'\n\nconst resetAction = NavigationActions.reset({\n  index: 0,\n  actions: [\n    NavigationActions.navigate({ routeName: 'Profile'})\n  ]\n})\nthis.props.navigation.dispatch(resetAction)\n\n```\n\nYou can issue multiple actions, but make sure to set `index` correctly:\n\n```js\nimport { NavigationActions } from 'react-navigation'\n\nconst resetAction = NavigationActions.reset({\n  index: 1,\n  actions: [\n    NavigationActions.navigate({ routeName: 'Profile'}),\n    NavigationActions.navigate({ routeName: 'Settings'})\n  ]\n})\nthis.props.navigation.dispatch(resetAction)\n\n```\n\n### SetParams\n\nWhen dispatching `SetParams`, the router will produce a new state that has changed the params of a particular route, as identified by the key\n\n```js\nimport { NavigationActions } from 'react-navigation'\n\nconst setParamsAction = NavigationActions.setParams({\n  params: {}, // these are the new params that will be merged into the existing route params\n  // The key of the route that should get the new params\n  key: 'screen-123',\n})\nthis.props.navigation.dispatch(setParamsAction)\n\n```\n","guides/Screen-Tracking":"## Screen tracking and analytics\n\nThis example shows how to do screen tracking and send to Google Analytics. The approach can be adapted to any other mobile analytics SDK. \n\n### Screen tracking\n\nWhen using built-in navigation container, we can use `onNavigationStateChange` to track the screen.\n\n```js\nimport { GoogleAnalyticsTracker } from 'react-native-google-analytics-bridge';\n\nconst tracker = new GoogleAnalyticsTracker(GA_TRACKING_ID);\n\n// gets the current screen from navigation state\nfunction getCurrentRouteName(navigationState) {\n  if (!navigationState) {\n    return null;\n  }\n  const route = navigationState.routes[navigationState.index];\n  // dive into nested navigators\n  if (route.routes) {\n    return getCurrentRouteName(route);\n  }\n  return route.routeName;\n}\n\nconst AppNavigator = StackNavigator(AppRouteConfigs);\n\nexport default () => (\n  <AppNavigator\n    onNavigationStateChange={(prevState, currentState) => {\n      const currentScreen = getCurrentRouteName(currentState);\n      const prevScreen = getCurrentRouteName(prevState);\n\n      if (prevScreen !== currentScreen) {\n        // the line below uses the Google Analytics tracker\n        // change the tracker here to use other Mobile analytics SDK.\n        tracker.trackScreenView(currentScreen);\n      }\n    }}\n  />\n);\n```\n\n### Screen tracking with Redux\n\nWhen using Redux, we can write a Redux middleware to track the screen. For this purpose,\nwe will reuse `getCurrentRouteName` from the previous section.\n\n```js\nimport { NavigationActions } from 'react-navigation';\nimport { GoogleAnalyticsTracker } from 'react-native-google-analytics-bridge';\n\nconst tracker = new GoogleAnalyticsTracker(GA_TRACKING_ID);\n\nconst screenTracking = ({ getState }) => next => (action) => {\n  if (\n    action.type !== NavigationActions.NAVIGATE\n    && action.type !== NavigationActions.BACK\n  ) {\n    return next(action);\n  }\n\n  const currentScreen = getCurrentRouteName(getState().navigation);\n  const result = next(action);\n  const nextScreen = getCurrentRouteName(getState().navigation);\n  if (nextScreen !== currentScreen) {\n    // the line below uses the Google Analytics tracker\n    // change the tracker here to use other Mobile analytics SDK.\n    tracker.trackScreenView(nextScreen);\n  }\n  return result;\n};\n\nexport default screenTracking;\n```\n\n### Create Redux store and apply the above middleware\n\nThe `screenTracking` middleware can be applied to the store during its creation. See [Redux Integration](Redux-Integration.md) for details.\n\n```js\nconst store = createStore(\n  combineReducers({\n    navigation: navigationReducer,\n    ...\n  }),\n  applyMiddleware(\n    screenTracking,\n    ...\n    ),\n);\n```\n","guides/Web-Integration":"# Web Integration\n\nReact Navigation routers work on web and allow you to share navigation logic with native apps. The views currently bundled in `react-navigation` currently only work on React Native, but that may change with future-facing projects like [react-primitives](https://github.com/lelandrichardson/react-primitives).\n\n## Example App\n\n[This website](https://reactnavigation.org/) is [built with](https://github.com/react-community/react-navigation/blob/master/website/) React Navigation, specifically using `createNavigator` and `TabRouter`.\n\nSee the source code of the site here: [App.js](https://github.com/react-community/react-navigation/blob/master/website/src/App.js).\n\nTo see how the app gets rendered on the server, see [Server.js](https://github.com/react-community/react-navigation/blob/master/website/src/Server.js). On the browser, the App wakes up and gets rendered with [BrowserAppContainer.js](https://github.com/react-community/react-navigation/blob/master/website/src/BrowserAppContainer.js).\n\n\n## More Coming Soon\n\nSoon this guide will be replaced with a more thorough walkthrough of react-navigation usage on the web.\n"}